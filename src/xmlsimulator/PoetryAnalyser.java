package xmlsimulator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Scanner;

import beast.core.Input;
import beast.core.Runnable;
import beast.core.parameter.Map;
import beast.core.util.ESS;
import beast.core.util.Log;
import beast.util.LogAnalyser;
import xmlsimulator.sampler.POEM;


/**
 * Reads in poems, a log file, and a database
 * Computes the ESS of any parameters in the log file which are specified by the poems, and inserts them into the database
 * The xml for this file is automatically generated by the SimulateXML class
 * @author jdou557
 *
 */
public class PoetryAnalyser extends Runnable {

	
	final public Input<File> databaseFileInput = new Input<>("database", "The location of a the database (tsv)", Input.Validate.REQUIRED);
	final public Input<Integer> sampleNumInput = new Input<>("number", "The row number in the database of this sample", Input.Validate.REQUIRED);
	final public Input<List<POEM>> poemsInput = new Input<>("poem", "A map between operators and log outputs", new ArrayList<>());
	
	final public Input<Integer> burninInput = new Input<>("burnin", "Burnin percentage for ESS computation (default 10)", 10);

	
	
	int sampleNum;
	int rowNum;
	File database;
	List<POEM> poems;
	HashMap<String, String[]> db;
	
	@Override
	public void initAndValidate() {
		
		this.sampleNum = sampleNumInput.get();
		this.database = databaseFileInput.get();
		this.poems = poemsInput.get();
		this.rowNum = -1;
		
		if (this.poems.isEmpty()) throw new IllegalArgumentException("Please provide at least 1 poem");
		
		// File validation
		
		if (!(this.database.exists())) throw new IllegalArgumentException("Could not locate database " + this.database.getPath());
		
		
		
	}

	@Override
	public void run() throws Exception {
		


		
		// Open logfile using loganalyser
		Log.warning("Computing ESSes...");
		
		//analyser.getESS(label);
		
		
		// Calculate ESS for each POEM
		for (POEM poem : this.poems) {
			
			File logFile = new File(poem.getLoggerFileName());
			if (!logFile.exists() || !logFile.canRead()) throw new IllegalArgumentException("Could not locate/read logfile " + logFile.getPath());
			LogAnalyser analyser = new LogAnalyser(logFile.getAbsolutePath(), this.burninInput.get(), true, null);
			
			
			// Get minimum ESS across all relevant column names
			double minESS = Double.POSITIVE_INFINITY;
			for (String colname : analyser.getLabels()) {

				double ESS = analyser.getESS(colname);
				if (ESS < 0 || Double.isNaN(ESS)) continue;
				minESS = Math.min(minESS, ESS);
			}
			System.out.println(poem.getID() + " has a minimum ESS of " + (int) minESS);
			poem.setMinESS(minESS);
			
			
			// Put in database array
			//this.setValueAtRow(poem.getESSColname(), "" + minESS);
			
		}
		
		
		// Save the new row to the database. This will lock the database file to avoid conflicts
		Log.warning("Saving to database...");
		this.updateDatabase();
		
		
		Log.warning("Done!");
		
	}
	
	
	
	private void updateDatabase() throws Exception {
		
		
		
		RandomAccessFile raf = new RandomAccessFile(this.database, "rw");
		FileChannel channel = raf.getChannel();
		//FileLock lock = channel.tryLock();
		

		// Open database and find the right line
		this.db = this.openDatabase();
		this.rowNum = this.getRowNum(this.sampleNum);
		if (this.rowNum < 0) throw new Exception("Cannot locate sample number " + this.sampleNum + " in the 'xml' column of the database");
		
		
		
		// Write ESSes
		for (POEM poem : poems) {
			this.setValueAtRow(poem.getESSColname(), "" + poem.getMinESS());
		}
		
		// Set all POEM ESSes and compute coefficient of variation
		double cov = POEM.getCoefficientOfVariation(this.poems);
		System.out.println("ESS coefficient of variation is " + cov);
		this.setValueAtRow(POEM.getCoefficientOfVariationColumnName(), "" + cov);
		
		
		// Get database string
		String out = "";
		for (String colname : this.db.keySet()) out += colname + "\t";
		out += "\n";
		int nrow = this.db.get("xml").length;
		for (int rowNum = 0; rowNum < nrow; rowNum ++) {
			for (String colname : this.db.keySet()) {
				out += this.db.get(colname)[rowNum] + "\t";
			}
			out += "\n";
		}
		
		
		// Clear the file and rewrite it 
		channel.truncate(0);
		raf.write(out.getBytes());
		//lock.close();
		
		
		/*
		
		// Sleep until the file can be written to
		RandomAccessFile raf = new RandomAccessFile(this.database, "rw");
		FileChannel channel = raf.getChannel();
		FileLock lock = channel.tryLock();
		int numSleeps = 0;
		while (lock == null) {
			Thread.sleep(100);
			numSleeps ++;
			if (numSleeps == 1 || numSleeps % 100 == 0) {
				Log.warning("Database is locked, waiting for it to unlock...");
			}
			lock = channel.tryLock();
		}
		
		lock = channel.lock();
		
		
		
		// Lock the file
		//try (RandomAccessFile fileOutputStream = new RandomAccessFile(this.database, "rw");
			//     FileChannel channel = fileOutputStream.getChannel();
			    // FileLock lock = channel.lock()) { 
			    
			
		
		
			// Open database and find the right line
			this.db = this.openDatabase();
			this.rowNum = this.getRowNum(this.sampleNum);
			if (this.rowNum < 0) throw new Exception("Cannot locate sample number " + this.sampleNum + " in the 'xml' column of the database");
			
			
			
			// Set all POEM ESSes
			for (POEM poem : this.poems) {
				this.setValueAtRow(poem.getESSColname(), "" + poem.getMinESS());
			}
			
		
			
		
			Log.warning("File locked. Sleeping now");
			Thread.sleep(1000000);
			
			// Get database string
			String out = "";
			for (String colname : this.db.keySet()) out += colname + "\t";
			out += "\n";
			int nrow = this.db.get("xml").length;
			for (int rowNum = 0; rowNum < nrow; rowNum ++) {
				for (String colname : this.db.keySet()) {
					out += this.db.get(colname)[rowNum] + "\t";
				}
				out += "\n";
			}
			
			
			// Clear the file and rewrite it 
			channel.truncate(0);
			raf.write(out.getBytes());
			lock.close();
		
	//}
	 * 
	 * */
	 
		
		
	}

	

	/**
	 * Gets the value at the specified column for this sampleNum in the database
	 * @param colname
	 * @return
	 */
	public String getValueAtRow(String colname) throws Exception {
		if (this.db == null || this.rowNum < 0) return null;
		if (!db.containsKey(colname)) throw new Exception("Cannot locate column " + colname + " in the database");
		String[] vals = db.get(colname);
		return vals[this.rowNum];
	}
	
	
	/**
	 * Set a value within this row of the database array
	 * @param colname
	 * @param value
	 */
	public void setValueAtRow(String colname, String value) throws Exception {
		if (this.db == null || this.rowNum < 0) return;
		if (!db.containsKey(colname)) throw new Exception("Cannot locate column " + colname + " in the database");
		String[] vals = db.get(colname);
		vals[this.rowNum] = value;
	}
	
	
	/**
	 * Gets the row number associated with this sample number
	 * @param sampleNum
	 * @return
	 */
	public int getRowNum(int sampleNum) {
		
		if (this.db == null) return -1;
		
		String sampleStr = "" + sampleNum;
		String[] ids = db.get("xml");
		for (int i = 0; i < ids.length; i ++) {
			if (sampleStr.equals(ids[i])) {
				return i;
			}
		}
		
		
		return -1;
		
	}
	
	
	
	/**
	 * Opens the database and returns it as a hashmap
	 * @return
	 * @throws Exception
	 */
	public LinkedHashMap<String, String[]> openDatabase() throws Exception {
		
		LinkedHashMap<String, String[]> map = new LinkedHashMap<String, String[]>();
		
		// Read headers
		Scanner scanner = new Scanner(this.database);
		String[] headers = scanner.nextLine().split("\t");
		int ncol = headers.length;
		List<String[]> values = new ArrayList<String[]>();
		
		// Read in data
		int lineNum = 1;
		while (scanner.hasNextLine()) {
			
			lineNum ++;
			String line = scanner.nextLine();
			if (line.isEmpty()) continue;
			String[] spl = line.split("\t");
			if (spl.length != ncol) throw new IllegalArgumentException("Database has " + spl.length + " elements on file line " + lineNum + " but there should be " + ncol);
			values.add(line.split("\t"));
			
		}
		
		
		// Build map
		int nrow = values.size();
		for (int colNum = 0; colNum < ncol; colNum ++) {
			String colname = headers[colNum];
			String[] vals = new String[nrow];
			for (int rowNum = 0; rowNum < nrow; rowNum ++) {
				String[] row = values.get(rowNum);
				String val = row[colNum];
				vals[rowNum] = val;
			}
			map.put(colname, vals);
		}
		
		
		// Check the xml column exists
		if (!map.containsKey("xml")) throw new IllegalArgumentException("Cannot locate 'xml' column in database");
		
		scanner.close();
		
		return map;
		
	}
	

}











