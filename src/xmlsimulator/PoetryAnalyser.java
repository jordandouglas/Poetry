package xmlsimulator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;

import beast.core.Input;
import beast.core.Runnable;
import beast.core.parameter.Map;
import beast.core.util.ESS;
import beast.core.util.Log;
import beast.util.LogAnalyser;
import xmlsimulator.sampler.POEM;


/**
 * Reads in poems, a log file, and a database
 * Computes the ESS of any parameters in the log file which are specified by the poems, and inserts them into the database
 * The xml for this file is automatically generated by the SimulateXML class
 * @author jdou557
 *
 */
public class PoetryAnalyser extends Runnable {

	
	final public Input<File> logfileInput = new Input<>("log", "The location of a log file", Input.Validate.REQUIRED);
	final public Input<File> databaseFileInput = new Input<>("database", "The location of a the database (tsv)", Input.Validate.REQUIRED);
	final public Input<Integer> sampleNumInput = new Input<>("number", "The row number in the database of this sample", Input.Validate.REQUIRED);
	final public Input<List<POEM>> poemsInput = new Input<>("poem", "A map between operators and log outputs", new ArrayList<>());
	
	final public Input<Integer> burninInput = new Input<>("burnin", "Burnin percentage for ESS computation (default 10)", 10);

	
	
	int sampleNum;
	int rowNum;
	File logFile;
	File database;
	List<POEM> poems;
	HashMap<String, String[]> db;
	
	@Override
	public void initAndValidate() {
		
		this.sampleNum = sampleNumInput.get();
		this.logFile = logfileInput.get();
		this.database = databaseFileInput.get();
		this.poems = poemsInput.get();
		this.rowNum = -1;
		
		if (this.poems.isEmpty()) throw new IllegalArgumentException("Please provide at least 1 poem");
		
		// File validation
		if (!this.logFile.exists() || !this.logFile.canRead()) throw new IllegalArgumentException("Could not locate/read logfile " + this.logFile.getPath());
		if (!this.database.exists() || !this.database.canRead()) throw new IllegalArgumentException("Could not locate database " + this.database.getPath());
		
		
		
	}

	@Override
	public void run() throws Exception {
		


		
		// Open logfile using loganalyser
		Log.warning("Computing ESSes...");
		LogAnalyser analyser = new LogAnalyser(this.logFile.getAbsolutePath(), this.burninInput.get(), true, null);
		//analyser.getESS(label);
		
		
		// Calculate ESS for each POEM
		Log.warning("Reading poems...");
		for (POEM poem : this.poems) {
			
			// Get minimum ESS across all relevant column names
			double minESS = Double.POSITIVE_INFINITY;
			for (String colname : poem.getLogIDs()) {
				
				// Temp HACK until I can get column names matching
				if (!colname.equals("posterior") && !colname.equals("likelihood") && !colname.equals("prior")) continue;
				
				double ESS = analyser.getESS(colname);
				if (ESS < 0 || Double.isNaN(ESS)) continue;
				minESS = Math.min(minESS, ESS);
			}
			System.out.println(poem.getID() + " has a minimum ESS of " + minESS);
			poem.setMinESS(minESS);
			
			
			// Put in database array
			//this.setValueAtRow(poem.getESSColname(), "" + minESS);
			
		}
		
		
		// Save the new row to the database. This will lock the database file to avoid conflicts
		Log.warning("Saving to database...");
		this.updateDatabase();
		
		
		Log.warning("Done!");
		
	}
	
	
	
	private void updateDatabase() throws Exception {
		
		
		// Sleep until the file can be written to
		int numSleeps = 0;
		while (!this.database.canWrite()) {
			Thread.sleep(100);
			numSleeps ++;
			if (numSleeps == 1 || numSleeps % 100 == 0) {
				Log.warning("Database is locked, waiting for it to unlock...");
			}
		}
		
		
		// Lock the file
		try (FileOutputStream fileOutputStream = new FileOutputStream(this.database);
			     FileChannel channel = fileOutputStream.getChannel();
			     FileLock lock = channel.lock()) { 
			    
			
				// Open database and find the right line
				this.db = this.openDatabase();
				this.rowNum = this.getRowNum(this.sampleNum);
				if (this.rowNum < 0) throw new Exception("Cannot locate sample number " + this.sampleNum + " in the 'xml' column of the database");
				
				// Set all POEM ESSes
				for (POEM poem : this.poems) {
					this.setValueAtRow(poem.getESSColname(), "" + poem.getMinESS());
				}
				
				// Get database string
				String out = "";
				for (String colname : this.db.keySet()) out += colname + "\t";
				out += "\n";
				int nrow = this.db.get("xml").length;
				for (int rowNum = 0; rowNum < nrow; rowNum ++) {
					for (String colname : this.db.keySet()) {
						out += this.db.get(colname)[rowNum] + "\t";
					}
					out += "\n";
				}
				
				
				// Write to file
				fileOutputStream.write(out.getBytes());
				fileOutputStream.close();
			
				/*
				// Find which line this line is on
				Scanner scanner = new Scanner(this.database);
				String[] headers = scanner.nextLine().split("\t");
				int xmlIndex = -1;
				for (int i = 0; i < headers.length; i++) {
					if (headers[i].equals("xml")) {
						xmlIndex = i;
						break;
					}
				}
				int lineNum = 0;
				while(scanner.hasNextLine()) {
					lineNum++;
					String line = scanner.nextLine();
					if (line.isEmpty()) continue;
					String[] bits = line.split("\t");
					String index = bits[xmlIndex];
					if (index.equals("" + this.sampleNum)) {
						break;
					}
				}
				scanner.close();
				*/
				
				
			
		}
		
		
	}

	/**
	 * Gets the value at the specified column for this sampleNum in the database
	 * @param colname
	 * @return
	 */
	public String getValueAtRow(String colname) throws Exception {
		if (this.db == null || this.rowNum < 0) return null;
		if (!db.containsKey(colname)) throw new Exception("Cannot locate column " + colname + " in the database");
		String[] vals = db.get(colname);
		return vals[this.rowNum];
	}
	
	
	/**
	 * Set a value within this row of the database array
	 * @param colname
	 * @param value
	 */
	public void setValueAtRow(String colname, String value) throws Exception {
		if (this.db == null || this.rowNum < 0) return;
		if (!db.containsKey(colname)) throw new Exception("Cannot locate column " + colname + " in the database");
		String[] vals = db.get(colname);
		vals[this.rowNum] = value;
	}
	
	
	/**
	 * Gets the row number associated with this sample number
	 * @param sampleNum
	 * @return
	 */
	public int getRowNum(int sampleNum) {
		
		if (this.db == null) return -1;
		
		String sampleStr = "" + sampleNum;
		String[] ids = db.get("xml");
		for (int i = 0; i < ids.length; i ++) {
			if (sampleStr.equals(ids[i])) {
				return i;
			}
		}
		
		
		return -1;
		
	}
	
	
	
	/**
	 * Opens the database and returns it as a hashmap
	 * @return
	 * @throws Exception
	 */
	public HashMap<String, String[]> openDatabase() throws Exception {
		
		HashMap<String, String[]> map = new HashMap<String, String[]>();
		
		// Read headers
		Scanner scanner = new Scanner(this.database);
		String[] headers = scanner.nextLine().split("\t");
		int ncol = headers.length;
		List<String[]> values = new ArrayList<String[]>();
		
		// Read in data
		int lineNum = 1;
		while (scanner.hasNextLine()) {
			
			lineNum ++;
			String line = scanner.nextLine();
			if (line.isEmpty()) continue;
			String[] spl = line.split("\t");
			if (spl.length != ncol) throw new IllegalArgumentException("Database has " + spl.length + " elements on file line " + lineNum + " but there should be " + ncol);
			values.add(line.split("\t"));
			
		}
		
		
		// Build map
		int nrow = values.size();
		for (int colNum = 0; colNum < ncol; colNum ++) {
			String colname = headers[colNum];
			String[] vals = new String[nrow];
			for (int rowNum = 0; rowNum < nrow; rowNum ++) {
				String[] row = values.get(rowNum);
				String val = row[colNum];
				vals[rowNum] = val;
			}
			map.put(colname, vals);
		}
		
		
		// Check the xml column exists
		if (!map.containsKey("xml")) throw new IllegalArgumentException("Cannot locate 'xml' column in database");
		
		scanner.close();
		
		return map;
		
	}
	

}











